<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[remember or forget]]></title>
  <link href="http://www.taopier.com/atom.xml" rel="self"/>
  <link href="http://www.taopier.com/"/>
  <updated>2014-02-26T17:50:08+08:00</updated>
  <id>http://www.taopier.com/</id>
  <author>
    <name><![CDATA[taopier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spark源码分析(一):worker]]></title>
    <link href="http://www.taopier.com/blog/2014/02/13/spark-source-code-worker/"/>
    <updated>2014-02-13T02:42:25+08:00</updated>
    <id>http://www.taopier.com/blog/2014/02/13/spark-source-code-worker</id>
    <content type="html"><![CDATA[<h4>it lies in spark-core, 主要就是在启动之前完成的准备工作，接收不同类型的消息进行相应的处理</h4>

<!-- more -->


<ul>
<li>preStart

<ul>
<li>创建自己的workDir</li>
<li>在master上注册自己

<ul>
<li>尝试在所有的master上注册：发送消息类型为RegisterWorker</li>
<li>如果没有成功，即registered这个标志位仍然为初始的false，则一共试3次，如果某一次注册成功，完成，否则放弃</li>
</ul>
</li>
<li>更新web ui页面（建立自己的metrics和相关链接)</li>
</ul>
</li>
<li>receive 根据消息类型进行相应处理

<ul>
<li>master相关

<ul>
<li>RegisteredWorker：从master接收的消息类型，注册成功，则更新自己的masterUrl，schedule发送固定间隔的SendHeartbeat类型的消息给自己</li>
<li>RegisterWorkerFailed：从master接收的消息类型，注册失败，直接退出</li>
<li>SendHeartbeat：若自己与master是连接的，则发送自己的id的心跳给master，消息类型为Heartbeat</li>
</ul>
</li>
<li>driver相关

<ul>
<li>Heartbeat： 接收到driver的心跳信息</li>
</ul>
</li>
<li>executor相关

<ul>
<li>LaunchExecutor</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[台湾自由行 Day1]]></title>
    <link href="http://www.taopier.com/blog/2013/05/10/travel-taiwan/"/>
    <updated>2013-05-10T22:42:25+08:00</updated>
    <id>http://www.taopier.com/blog/2013/05/10/travel-taiwan</id>
    <content type="html"><![CDATA[<p>海航 北京-桃园-台北</p>

<hr />

<p>天气预报上看 未来一周台湾各地都是各种不同程度的雨，心想，这样也好，就下着雨逛各景点吧，起码天气不会太热，从大陆这边的天空上 还是蓝天白云 但是不知从何时起 就变成各种灰度的云层，本来还想亲眼俯视下跨越的台湾海峡，毕竟 这是鄙人第一次人肉翻墙，夹杂着儿时被灌输的“被台湾海峡分隔开的大陆和台湾，balabala”，总觉得人肉在海峡上空是件有着重大意义的事，但充溢着整个空间的各种云层，把肉眼可见海峡的概率 阻挡为0，带着这样的遗憾</p>

<!-- more -->


<hr />

<p>转折</p>

<p>所谓有失有得，儿时还因为西游记的关系 对各种腾云驾雾有着非凡的情结，看惯了从下面仰视上面白云的角度，猜度着某个比较厚的云朵上就隐匿着某神仙的宫殿，一直盯着盯着，也许一瞬间，会有宫殿的踪迹出来。而当自己处在云层包围中时，又是另一番视角了，离得近的都是似雾一样的水汽，不识真面目，只缘此山中，看上面或者下面的云团 则因为有阳光的投射，光影效果特别的美，一副3D立体画，看到了一片略有起伏的云海上突兀出一柱马头，很有马头星云的艳影，或者突兀出三五从，每个点位都演绎着不同的光影之美，只恨自己摄影技术不佳，无法将这种美定格，只能印在脑海里，见过这种最天然的透射光影，起码，足矣</p>

<hr />

<p>转折</p>

<p>到了桃园机场入境大厅，人也不少呀，但是第一感觉就是特别的静，人说话都收声敛气，周围入境的工作人员让我想起了李大仁和“代表月亮消灭你”的Maggie。声音一律是没有做作的嗲，会让你觉到全身酥麻，等办完入境，大厅里的其他工作人员给人的感觉基本上都是一致的，温文尔雅，热心有礼,这就是台湾的第一印象了，来自于当地的人文情怀（想起让人作呕的宣传语 “做文明有礼的xx人”，这边是浮在上面，那边是深入骨髓，这就是差异）</p>

<p>从桃园到台北的大巴上（由于我误买的大有巴士，而非推荐的国光），沿途基本上在有人的地方穿行，速度没有后者快，但我觉得可以更深入的看到台北的非主市区的景致，更全面的看到一个城市的面貌，而非是刻意展示给外地人的部分，不得不说的是，一路上景致真的很美，各种青山绿水，应该是由于气候环境原因，那叫一个青翠欲滴，那叫一个各种浓度的绿，还有常见穿梭于山间或者平地的小河，养眼吧，只能说，中途还绕着原山饭店转了一圈，也算是所失所得了。但是由于从飞机准备降落和大巴沿途过的建筑物，真的无法让人相信这是一个所谓的大城市，绝大部分建筑看上去都那么破旧，和大陆这边一个不太发达的小县城有的一拼了。这算是第二印象吧</p>

<hr />

<p><img class="left" src="http://www.taopier.com/images/taiwan/day1.png" title="台北-宁夏夜市" >
到了宾馆，冲澡，休息，睁眼已经晚上了，就逛到了宁夏夜市，享受第一晚的台湾美食</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backgroud Part I : Akka Actor]]></title>
    <link href="http://www.taopier.com/blog/2013/01/26/akka-actor/"/>
    <updated>2013-01-26T17:33:11+08:00</updated>
    <id>http://www.taopier.com/blog/2013/01/26/akka-actor</id>
    <content type="html"><![CDATA[<h1>Actor Systems</h1>

<p>Hierarchical Structure: One actor, which is to oversee a certain function in the program might want to split up its task into smaller, more manageable pieces.</p>

<!-- more -->


<p><em>taopier: each actor has exactly one supervisor, which is the actor that created it.</em></p>

<h2>what&rsquo;s an ackor</h2>

<p>An actor is a container for State, Behavior, a Mailbox, Children and a Supervisor Strategy. All of this is encapsulated behind an Actor Reference.</p>

<p><strong>Actor Reference</strong> : actors are represented to the outside using actor references, which are objects that can be passed around freely and without restriction.</p>

<p><em>taopier: restarting an actor without needing to update references elsewhere</em></p>

<p><strong>State</strong> : Actor objects will typically contain some variables which reflect possible states the actor may be in. This can be an explicit state machine (e.g. using the FSM module), or it could be a counter, set of listeners, pending requests, etc.</p>

<p>what&rsquo;s <a href="http://doc.akka.io/docs/akka/snapshot/scala/fsm.html#fsm-scala">FSM</a>: The FSM (Finite State Machine) is available as a mixin for the akka Actor and is best described in the Erlang design principles</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A FSM can be described as a set of relations of the form:
</span><span class='line'>
</span><span class='line'>State(S) x Event(E) -&gt; Actions (A), State(S')
</span><span class='line'>
</span><span class='line'>These relations are interpreted as meaning:
</span><span class='line'>
</span><span class='line'>If we are in state S and the event E occurs, we should perform the actions A and make a transition to the state S'.</span></code></pre></td></tr></table></div></figure>


<p><strong>Behavior</strong> : Every time a message is processed, it is matched against the current behavior of the actor. Behavior means a function which defines the actions to be taken in reaction to the message at that point in time</p>

<p><strong>Mailbox</strong> : The piece which connects sender and receiver is the actor’s mailbox: each actor has exactly one mailbox to which all senders enqueue their messages.</p>

<p><em>taopier: the default strategy is FIFO, and can be set using Priority( the current behavior must always handle the next dequeued message, there is no scanning the mailbox for the next matching one. so this strategy cat actually put messages into front)</em></p>

<p><strong>Children</strong>: Each actor is potentially a supervisor: if it creates children for delegating sub-tasks, it will automatically supervise them. The list of children is maintained within the actor’s context and the actor has access to it. Modifications to the list are done by creating (context.actorOf(&hellip;)) or stopping (context.stop(child)) children and these actions are reflected immediately. The actual creation and termination actions happen behind the scenes in an asynchronous way, so they do not “block” their supervisor.</p>

<p><strong>Supervisor Strategy</strong> : handling faults of its children</p>

<h2>Supervision and Monitoring</h2>

<h3>what supervision means</h3>

<p>When a subordinate detects a failure (i.e. throws an exception), it suspends itself and all its subordinates and sends a message to its supervisor, signaling failure.the supervisor has a choice of the following four options:</p>

<ol>
<li>Resume the subordinate, keeping its accumulated internal state</li>
<li>Restart the subordinate, clearing out its accumulated internal state</li>
<li>Terminate the subordinate permanently</li>
<li>Escalate the failure</li>
</ol>


<p><em>taopier: the default behaviour of the preRestart hook of the Actor class is to terminate all its children before restarting, but this hook can be overridden</em></p>

<h3>The Top-Level Supervisors</h3>

<p><strong>/user: The Guardian Actor</strong> The actor which is probably most interacted with is the parent of all user-created actors, the guardian named &ldquo;/user&rdquo;. Actors created using system.actorOf() are children of this actor.</p>

<p><strong>/system: The System Guardian</strong>  in order to achieve an orderly shut-down sequence where logging remains active while all normal actors terminate</p>

<p><strong>/: The Root Guardian</strong> The root guardian is the grand-parent of all so-called “top-level” actors and supervises all the special actors mentioned in Top-Level Scopes for Actor Paths using the SupervisorStrategy.stoppingStrategy, whose purpose is to terminate the child upon any type of Exception.</p>

<h3>what restarting means</h3>

<p>The precise sequence of events during a restart is the following:</p>

<ol>
<li>suspend the actor (which means that it will not process normal messages until resumed), and recursively suspend all children</li>
<li>call the old instance’s preRestart hook (defaults to sending termination requests to all children and calling postStop)</li>
<li>wait for all children which were requested to terminate (using context.stop()) during preRestart to actually terminate; this—like all actor operations—is non-blocking, the termination notice from the last killed child will effect the progression to the next step</li>
<li>create new actor instance by invoking the originally provided factory again</li>
<li>invoke postRestart on the new instance (which by default also calls preStart)</li>
<li>send restart request to all children which were not killed in step 3; restarted children will follow the same process recursively, from step 2</li>
<li>resume the actor</li>
</ol>


<h3>supervision strategies</h3>

<p>two classes of supervision strategies which come with Akka: OneForOneStrategy(by default) and AllForOneStrategy.</p>

<p><em>difference: the former applies the obtained directive only to the failed child, whereas the latter applies it to all siblings as well.</em></p>

<h2>Actor References, Paths and Addresses</h2>

<p><img src="http://www.taopier.com/images/code/entity-of-actor.png" title="entity of actor" ></p>

<p>The above image displays the relationship between the most important entities within an actor system, please read on for the details.</p>

<p><strong>What is an Actor Reference?</strong></p>

<p>An actor reference is a subtype of ActorRef, whose foremost purpose is to support sending messages to the actor it represents.</p>

<p><strong>What is an Actor Path?</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"akka://my-sys/user/service-a/worker1"                   // purely local
</span><span class='line'>"akka.tcp://my-sys@host.example.com:5678/user/service-b" // remote
</span><span class='line'>"cluster://my-cluster/service-c"                         // clustered (Future Extension)</span></code></pre></td></tr></table></div></figure>


<p><strong>Logical Actor Paths / Physical Actor Paths:</strong></p>

<p>like our system: /home/taopier/ vs ../taopier/</p>

<p><strong>How are Actor References obtained?</strong></p>

<p>Creating Actors by using ActorSystem.actorOf method or using ActorContext.actorOf</p>

<p>Looking up Actors by Concrete Path: ActorSystem.actorFor or ActorContext.actorFor</p>

<p>You can for example send a message to a specific sibling:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorFor("../brother") ! msg</span></code></pre></td></tr></table></div></figure>


<p>Absolute paths may of course also be looked up on context in the usual way, i.e.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorFor("/user/serviceA") ! msg</span></code></pre></td></tr></table></div></figure>


<p>will work as expected.</p>

<p><strong>Querying the Logical Actor Hierarchy</strong></p>

<p>using the ActorSystem.actorSelection and ActorContext.actorSelection methods and do support sending messages:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorSelection("../*") ! msg</span></code></pre></td></tr></table></div></figure>


<p>will send msg to all siblings including the current actor.</p>

<p><strong>The Interplay with Remote Deployment</strong></p>

<p>When an actor creates a child, the actor system’s deployer will decide whether the new actor resides in the same JVM or on another node. In the second case, creation of the actor will be triggered via a network connection to happen in a different JVM and consequently within a different actor system. The remote system will place the new actor below a special path reserved for this purpose and the supervisor of the new actor will be a remote actor reference (representing that actor which triggered its creation). In this case, context.parent (the supervisor reference) and context.path.parent (the parent node in the actor’s path) do not represent the same actor.</p>

<p><strong>Top-Level Scopes for Actor Paths</strong></p>

<p>At the root of the path hierarchy resides the root guardian above which all other actors are found; its name is &ldquo;/&rdquo;. The next level consists of the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"/user" is the guardian actor for all user-created top-level actors; actors created using ActorSystem.actorOf are found below this one.
</span><span class='line'>"/system" is the guardian actor for all system-created top-level actors, e.g. logging listeners or actors automatically deployed by configuration at the start of the actor system.
</span><span class='line'>"/deadLetters" is the dead letter actor, which is where all messages sent to stopped or non-existing actors are re-routed (on a best-effort basis: messages may be lost even within the local JVM).
</span><span class='line'>"/temp" is the guardian for all short-lived system-created actors, e.g. those which are used in the implementation of ActorRef.ask.
</span><span class='line'>"/remote" is an artificial path below which all actors reside whose supervisors are remote actor references</span></code></pre></td></tr></table></div></figure>


<h1>Reference</h1>

<p><a href="http://www.gtan.com/akka_doc/intro/getting-started-first-scala.html">http://www.gtan.com/akka_doc/intro/getting-started-first-scala.html</a></p>

<p><a href="http://doc.akka.io/docs/akka/snapshot/">http://doc.akka.io/docs/akka/snapshot/</a></p>
]]></content>
  </entry>
  
</feed>
