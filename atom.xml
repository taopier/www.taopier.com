<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[remember or forget]]></title>
  <link href="http://www.taopier.com/atom.xml" rel="self"/>
  <link href="http://www.taopier.com/"/>
  <updated>2014-03-29T08:16:45+09:00</updated>
  <id>http://www.taopier.com/</id>
  <author>
    <name><![CDATA[taopier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[霓虹 Day1:东京]]></title>
    <link href="http://www.taopier.com/blog/2014/03/28/japan-day1-tokyo/"/>
    <updated>2014-03-28T23:05:32+09:00</updated>
    <id>http://www.taopier.com/blog/2014/03/28/japan-day1-tokyo</id>
    <content type="html"><![CDATA[<hr />

<p>可能因为在帝都生活太久了 初到这里 就觉得哪儿哪儿都干净 在从机场到东京的路上，看到在主色调是蓝色和绿色的画板上渐次出现的小建筑群，熠熠闪烁着中国古风，周边地势略有些起伏，加上看起来高耸的植物群，倒像是一并簇拥着这些群落。心底就觉得这大抵就是和谐吧</p>

<!-- more -->


<p>到了东京，第一感觉就是生活节奏好快，路旁行人的步伐一律都是匆匆，在酒店稍事休整后，跟cmh先去了新宿，打算先把disney的门票买了，卖票的地方号称18点关门，我们紧赶慢赶，18:05才找到了那个地方，门口一个服务生拿着个牌子18:00 close，上去软磨硬泡，就是不让我们进去买，这个嘛，往好了说是严谨认真，不好了说就是不近人情，作罢。</p>

<p>这段时间刚好是这边工作日的下班晚高峰，让我有机会见到了这边上班族的一角，惊讶，只能用惊讶来形容：男的无论是二十岁的，还是五六十岁的，清一色的正装领带皮鞋，地铁里放眼望去，十有八九都是这样，在国内被中介毁了的正装，在这边是如此的稀松。手里还都提一个包，公文包，修饰包，电脑包，etc.如此的大一统，如此的一本正经，好了说是严谨认真，坏了说是压抑人性（不然为何霓虹国的大叔都隐约觉得心理变态，我觉得跟这种日常生活的压抑是有关的，笑）</p>

<p>好不容易看到两个无业游民的痞子样 站在地铁里，穿着便装，我刚跟cmh说完：来我在这边也是痞子形象了，因为便装太过于扎眼了，在这个时候的晚高峰。就听到一句浓浓的东北味从那两个&#8221;痞子&#8221;嘴里飘出来：“哎呀 妈呀 坐到哪哪儿&#8221; 顿时我就石化了</p>

<p>吃的方面，就是觉得干净，这边的一份饭/面 的量真的很大，我觉得够我吃两顿的，当然折成人民币也小贵，在一家店吃了一份拉面？到另外一家吃了一份咖喱饭，之前看攻略似乎一般剩下都不礼貌，没想到这么大的量，目测周围男女吃完的盘子都很干净，也只能硬撑着往肚子里塞了</p>

<p><img class="left" src="http://www.taopier.com/images/japan/day1_1.png" title="拉面变种" ></p>

<p>路过东京站的时候，才发现人家100周年庆了，复杂的站点，也算是一段历史了，第三个图是东京站的</p>

<p><img class="left" src="http://www.taopier.com/images/japan/day1_2.png" title="咖喱饭-地铁小吃" ></p>

<p>不过后来shopping的路上，从18-21点 都还是有很多正装皮鞋拎包男出现在各个角落，总觉得有些别扭，尤其是在这边很大的一个UNIQLO里面，挑衣服，哎 不做点评</p>

<p>旅途劳顿，回到住处，去泡了个汤……还是学到不少东西，比如遮羞布（羞羞）放着靡靡之音，泡汤，霓虹的人还是很会享受的，我们住的酒店在东京算是蛮便宜的，但是里面的设施真的很赞，有特高级的空气净化器和马桶，虽不大，窗外也还算有点风景</p>

<p><img class="left" src="http://www.taopier.com/images/japan/day1_3.png" title="住处" ></p>

<p>顺带一提，到目前为止路过的各种场合，都觉得特别的规矩，就连小村落里面零散停放的车，在窄窄的空间里面都觉得规则有序，不得不佩服</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark源码分析(一):worker]]></title>
    <link href="http://www.taopier.com/blog/2014/02/13/spark-source-code-worker/"/>
    <updated>2014-02-13T03:42:25+09:00</updated>
    <id>http://www.taopier.com/blog/2014/02/13/spark-source-code-worker</id>
    <content type="html"><![CDATA[<h4>it lies in spark-core, 主要就是在启动之前完成的准备工作，接收不同类型的消息进行相应的处理</h4>

<!-- more -->


<ul>
<li>preStart

<ul>
<li>创建自己的workDir</li>
<li>在master上注册自己

<ul>
<li>尝试在所有的master上注册：发送消息类型为RegisterWorker</li>
<li>如果没有成功，即registered这个标志位仍然为初始的false，则一共试3次，如果某一次注册成功，完成，否则放弃</li>
</ul>
</li>
<li>更新web ui页面（建立自己的metrics和相关链接)</li>
</ul>
</li>
<li>receive 根据消息类型进行相应处理

<ul>
<li>master相关

<ul>
<li>RegisteredWorker：从master接收的消息类型，注册成功，则更新自己的masterUrl，schedule发送固定间隔的SendHeartbeat类型的消息给自己</li>
<li>RegisterWorkerFailed：从master接收的消息类型，注册失败，直接退出</li>
<li>SendHeartbeat：若自己与master是连接的，则发送自己的id的心跳给master，消息类型为Heartbeat</li>
</ul>
</li>
<li>driver相关

<ul>
<li>Heartbeat： 接收到driver的心跳信息</li>
</ul>
</li>
<li>executor相关

<ul>
<li>LaunchExecutor</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Actors and Concurrency]]></title>
    <link href="http://www.taopier.com/blog/2014/02/10/actors-and-concurrency/"/>
    <updated>2014-02-10T19:04:16+09:00</updated>
    <id>http://www.taopier.com/blog/2014/02/10/actors-and-concurrency</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[台湾自由行 Day1]]></title>
    <link href="http://www.taopier.com/blog/2013/05/10/travel-taiwan/"/>
    <updated>2013-05-10T23:42:25+09:00</updated>
    <id>http://www.taopier.com/blog/2013/05/10/travel-taiwan</id>
    <content type="html"><![CDATA[<p>海航 北京-桃园-台北</p>

<hr />

<p>天气预报上看 未来一周台湾各地都是各种不同程度的雨，心想，这样也好，就下着雨逛各景点吧，起码天气不会太热，从大陆这边的天空上 还是蓝天白云 但是不知从何时起 就变成各种灰度的云层，本来还想亲眼俯视下跨越的台湾海峡，毕竟 这是鄙人第一次人肉翻墙，夹杂着儿时被灌输的“被台湾海峡分隔开的大陆和台湾，balabala”，总觉得人肉在海峡上空是件有着重大意义的事，但充溢着整个空间的各种云层，把肉眼可见海峡的概率 阻挡为0，带着这样的遗憾</p>

<!-- more -->


<hr />

<p>转折</p>

<p>所谓有失有得，儿时还因为西游记的关系 对各种腾云驾雾有着非凡的情结，看惯了从下面仰视上面白云的角度，猜度着某个比较厚的云朵上就隐匿着某神仙的宫殿，一直盯着盯着，也许一瞬间，会有宫殿的踪迹出来。而当自己处在云层包围中时，又是另一番视角了，离得近的都是似雾一样的水汽，不识真面目，只缘此山中，看上面或者下面的云团 则因为有阳光的投射，光影效果特别的美，一副3D立体画，看到了一片略有起伏的云海上突兀出一柱马头，很有马头星云的艳影，或者突兀出三五从，每个点位都演绎着不同的光影之美，只恨自己摄影技术不佳，无法将这种美定格，只能印在脑海里，见过这种最天然的透射光影，起码，足矣</p>

<hr />

<p>转折</p>

<p>到了桃园机场入境大厅，人也不少呀，但是第一感觉就是特别的静，人说话都收声敛气，周围入境的工作人员让我想起了李大仁和“代表月亮消灭你”的Maggie。声音一律是没有做作的嗲，会让你觉到全身酥麻，等办完入境，大厅里的其他工作人员给人的感觉基本上都是一致的，温文尔雅，热心有礼,这就是台湾的第一印象了，来自于当地的人文情怀（想起让人作呕的宣传语 “做文明有礼的xx人”，这边是浮在上面，那边是深入骨髓，这就是差异）</p>

<p>从桃园到台北的大巴上（由于我误买的大有巴士，而非推荐的国光），沿途基本上在有人的地方穿行，速度没有后者快，但我觉得可以更深入的看到台北的非主市区的景致，更全面的看到一个城市的面貌，而非是刻意展示给外地人的部分，不得不说的是，一路上景致真的很美，各种青山绿水，应该是由于气候环境原因，那叫一个青翠欲滴，那叫一个各种浓度的绿，还有常见穿梭于山间或者平地的小河，养眼吧，只能说，中途还绕着原山饭店转了一圈，也算是所失所得了。但是由于从飞机准备降落和大巴沿途过的建筑物，真的无法让人相信这是一个所谓的大城市，绝大部分建筑看上去都那么破旧，和大陆这边一个不太发达的小县城有的一拼了。这算是第二印象吧</p>

<hr />

<p><img class="left" src="http://www.taopier.com/images/taiwan/day1.png" title="台北-宁夏夜市" >
到了宾馆，冲澡，休息，睁眼已经晚上了，就逛到了宁夏夜市，享受第一晚的台湾美食,现在还记得的有：月亮虾饼（似乎很有名，但其实是油炸，油很大，量大，味美，价廉），蛋黄芋饼（真真的整只蛋黄在里面，排队的人很多，味美）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backgroud Part I : Akka Actor]]></title>
    <link href="http://www.taopier.com/blog/2013/01/26/akka-actor/"/>
    <updated>2013-01-26T18:33:11+09:00</updated>
    <id>http://www.taopier.com/blog/2013/01/26/akka-actor</id>
    <content type="html"><![CDATA[<h1>Actor Systems in akka</h1>

<p>Hierarchical Structure: One actor, which is to oversee a certain function in the program might want to split up its task into smaller, more manageable pieces.</p>

<!-- more -->


<p><em>taopier: each actor has exactly one supervisor, which is the actor that created it.</em></p>

<h2>what&rsquo;s an ackor</h2>

<p>An actor is a container for State, Behavior, a Mailbox, Children and a Supervisor Strategy. All of this is encapsulated behind an Actor Reference.</p>

<p><strong>Actor Reference</strong> : actors are represented to the outside using actor references, which are objects that can be passed around freely and without restriction.</p>

<p><em>taopier: restarting an actor without needing to update references elsewhere</em></p>

<p><strong>State</strong> : Actor objects will typically contain some variables which reflect possible states the actor may be in. This can be an explicit state machine (e.g. using the FSM module), or it could be a counter, set of listeners, pending requests, etc.</p>

<p>what&rsquo;s <a href="http://doc.akka.io/docs/akka/snapshot/scala/fsm.html#fsm-scala">FSM</a>: The FSM (Finite State Machine) is available as a mixin for the akka Actor and is best described in the Erlang design principles</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A FSM can be described as a set of relations of the form:
</span><span class='line'>
</span><span class='line'>State(S) x Event(E) -&gt; Actions (A), State(S')
</span><span class='line'>
</span><span class='line'>These relations are interpreted as meaning:
</span><span class='line'>
</span><span class='line'>If we are in state S and the event E occurs, we should perform the actions A and make a transition to the state S'.</span></code></pre></td></tr></table></div></figure>


<p><strong>Behavior</strong> : Every time a message is processed, it is matched against the current behavior of the actor. Behavior means a function which defines the actions to be taken in reaction to the message at that point in time</p>

<p><strong>Mailbox</strong> : The piece which connects sender and receiver is the actor’s mailbox: each actor has exactly one mailbox to which all senders enqueue their messages.</p>

<p><em>taopier: the default strategy is FIFO, and can be set using Priority( the current behavior must always handle the next dequeued message, there is no scanning the mailbox for the next matching one. so this strategy cat actually put messages into front)</em></p>

<p><strong>Children</strong>: Each actor is potentially a supervisor: if it creates children for delegating sub-tasks, it will automatically supervise them. The list of children is maintained within the actor’s context and the actor has access to it. Modifications to the list are done by creating (context.actorOf(&hellip;)) or stopping (context.stop(child)) children and these actions are reflected immediately. The actual creation and termination actions happen behind the scenes in an asynchronous way, so they do not “block” their supervisor.</p>

<p><strong>Supervisor Strategy</strong> : handling faults of its children</p>

<h2>Supervision and Monitoring</h2>

<h3>what supervision means</h3>

<p>When a subordinate detects a failure (i.e. throws an exception), it suspends itself and all its subordinates and sends a message to its supervisor, signaling failure.the supervisor has a choice of the following four options:</p>

<ol>
<li>Resume the subordinate, keeping its accumulated internal state</li>
<li>Restart the subordinate, clearing out its accumulated internal state</li>
<li>Terminate the subordinate permanently</li>
<li>Escalate the failure</li>
</ol>


<p><em>taopier: the default behaviour of the preRestart hook of the Actor class is to terminate all its children before restarting, but this hook can be overridden</em></p>

<h3>The Top-Level Supervisors</h3>

<p><strong>/user: The Guardian Actor</strong> The actor which is probably most interacted with is the parent of all user-created actors, the guardian named &ldquo;/user&rdquo;. Actors created using system.actorOf() are children of this actor.</p>

<p><strong>/system: The System Guardian</strong>  in order to achieve an orderly shut-down sequence where logging remains active while all normal actors terminate</p>

<p><strong>/: The Root Guardian</strong> The root guardian is the grand-parent of all so-called “top-level” actors and supervises all the special actors mentioned in Top-Level Scopes for Actor Paths using the SupervisorStrategy.stoppingStrategy, whose purpose is to terminate the child upon any type of Exception.</p>

<h3>what restarting means</h3>

<p>The precise sequence of events during a restart is the following:</p>

<ol>
<li>suspend the actor (which means that it will not process normal messages until resumed), and recursively suspend all children</li>
<li>call the old instance’s preRestart hook (defaults to sending termination requests to all children and calling postStop)</li>
<li>wait for all children which were requested to terminate (using context.stop()) during preRestart to actually terminate; this—like all actor operations—is non-blocking, the termination notice from the last killed child will effect the progression to the next step</li>
<li>create new actor instance by invoking the originally provided factory again</li>
<li>invoke postRestart on the new instance (which by default also calls preStart)</li>
<li>send restart request to all children which were not killed in step 3; restarted children will follow the same process recursively, from step 2</li>
<li>resume the actor</li>
</ol>


<h3>supervision strategies</h3>

<p>two classes of supervision strategies which come with Akka: OneForOneStrategy(by default) and AllForOneStrategy.</p>

<p><em>difference: the former applies the obtained directive only to the failed child, whereas the latter applies it to all siblings as well.</em></p>

<h2>Actor References, Paths and Addresses</h2>

<p><img src="http://www.taopier.com/images/code/entity-of-actor.png" title="entity of actor" ></p>

<p>The above image displays the relationship between the most important entities within an actor system, please read on for the details.</p>

<p><strong>What is an Actor Reference?</strong></p>

<p>An actor reference is a subtype of ActorRef, whose foremost purpose is to support sending messages to the actor it represents.</p>

<p><strong>What is an Actor Path?</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"akka://my-sys/user/service-a/worker1"                   // purely local
</span><span class='line'>"akka.tcp://my-sys@host.example.com:5678/user/service-b" // remote
</span><span class='line'>"cluster://my-cluster/service-c"                         // clustered (Future Extension)</span></code></pre></td></tr></table></div></figure>


<p><strong>Logical Actor Paths / Physical Actor Paths:</strong></p>

<p>like our system: /home/taopier/ vs ../taopier/</p>

<p><strong>How are Actor References obtained?</strong></p>

<p>Creating Actors by using ActorSystem.actorOf method or using ActorContext.actorOf</p>

<p>Looking up Actors by Concrete Path: ActorSystem.actorFor or ActorContext.actorFor</p>

<p>You can for example send a message to a specific sibling:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorFor("../brother") ! msg</span></code></pre></td></tr></table></div></figure>


<p>Absolute paths may of course also be looked up on context in the usual way, i.e.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorFor("/user/serviceA") ! msg</span></code></pre></td></tr></table></div></figure>


<p>will work as expected.</p>

<p><strong>Querying the Logical Actor Hierarchy</strong></p>

<p>using the ActorSystem.actorSelection and ActorContext.actorSelection methods and do support sending messages:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>context.actorSelection("../*") ! msg</span></code></pre></td></tr></table></div></figure>


<p>will send msg to all siblings including the current actor.</p>

<p><strong>The Interplay with Remote Deployment</strong></p>

<p>When an actor creates a child, the actor system’s deployer will decide whether the new actor resides in the same JVM or on another node. In the second case, creation of the actor will be triggered via a network connection to happen in a different JVM and consequently within a different actor system. The remote system will place the new actor below a special path reserved for this purpose and the supervisor of the new actor will be a remote actor reference (representing that actor which triggered its creation). In this case, context.parent (the supervisor reference) and context.path.parent (the parent node in the actor’s path) do not represent the same actor.</p>

<p><strong>Top-Level Scopes for Actor Paths</strong></p>

<p>At the root of the path hierarchy resides the root guardian above which all other actors are found; its name is &ldquo;/&rdquo;. The next level consists of the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"/user" is the guardian actor for all user-created top-level actors; actors created using ActorSystem.actorOf are found below this one.
</span><span class='line'>"/system" is the guardian actor for all system-created top-level actors, e.g. logging listeners or actors automatically deployed by configuration at the start of the actor system.
</span><span class='line'>"/deadLetters" is the dead letter actor, which is where all messages sent to stopped or non-existing actors are re-routed (on a best-effort basis: messages may be lost even within the local JVM).
</span><span class='line'>"/temp" is the guardian for all short-lived system-created actors, e.g. those which are used in the implementation of ActorRef.ask.
</span><span class='line'>"/remote" is an artificial path below which all actors reside whose supervisors are remote actor references</span></code></pre></td></tr></table></div></figure>


<h1>Reference</h1>

<p><a href="http://www.gtan.com/akka_doc/intro/getting-started-first-scala.html">http://www.gtan.com/akka_doc/intro/getting-started-first-scala.html</a></p>

<p><a href="http://doc.akka.io/docs/akka/snapshot/">http://doc.akka.io/docs/akka/snapshot/</a></p>
]]></content>
  </entry>
  
</feed>
